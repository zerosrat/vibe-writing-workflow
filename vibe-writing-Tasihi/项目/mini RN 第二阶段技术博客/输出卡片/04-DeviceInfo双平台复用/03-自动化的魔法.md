## 🪄 代码会自己选择平台？
前面我们看到了同一个模块在不同平台的不同实现，但这里有个神奇的问题：
**编译器怎么知道该用哪个版本的代码？**
你总不能每次切换平台都手动改代码吧？

## 🎯 CMake 的智能选择
答案藏在构建系统里：

```cmake
# 平台特定源文件
if(APPLE)
    # 根据具体平台选择源文件
    if(${CMAKE_SYSTEM_NAME} MATCHES "iOS")
        set(PLATFORM_SOURCES
            src/ios/modules/deviceinfo/DeviceInfoModule.mm
        )
    else()
        # macOS
        set(PLATFORM_SOURCES
            src/macos/modules/deviceinfo/DeviceInfoModule.mm
        )
    endif()
    # 设置 Objective-C++ 编译标志
    set_source_files_properties(${PLATFORM_SOURCES}
        PROPERTIES COMPILE_FLAGS "-fobjc-arc")
elseif(ANDROID)
    set(PLATFORM_SOURCES
        # src/android/modules/deviceinfo/DeviceInfoModule.cpp  # 未来添加
    )
endif()

# 所有源文件
set(ALL_SOURCES
    ${COMMON_SOURCES}
    ${PLATFORM_SOURCES}
)

# 创建静态库
add_library(mini_react_native STATIC ${ALL_SOURCES})
```

**太聪明了！**

CMake 在配置阶段就决定了要编译哪些源文件。iOS 构建时只包含 iOS 版本，macOS 构建时只包含 macOS 版本。注意它还自动设置了 Objective-C++ 的 ARC 编译标志。

**这意味着什么？**

最终的二进制文件里根本没有另一个平台的代码！不是运行时判断，而是编译时就确定了。

## 🔧 框架链接的精准控制

更神奇的是，不同平台需要链接不同的系统框架：

```cmake
# 平台特定框架
if(${CMAKE_SYSTEM_NAME} MATCHES "iOS")
    # iOS 特定框架
    find_library(UIKIT_FRAMEWORK UIKit)
    if(NOT UIKIT_FRAMEWORK)
        message(FATAL_ERROR "UIKit framework not found")
    endif()
    set(PLATFORM_FRAMEWORKS ${UIKIT_FRAMEWORK})
else()
    # macOS 特定框架
    find_library(IOKIT_FRAMEWORK IOKit)
    if(NOT IOKIT_FRAMEWORK)
        message(FATAL_ERROR "IOKit framework not found")
    endif()
    set(PLATFORM_FRAMEWORKS ${IOKIT_FRAMEWORK})
endif()

# 链接所需框架
target_link_libraries(mini_react_native
    ${JAVASCRIPTCORE_FRAMEWORK}
    ${FOUNDATION_FRAMEWORK}
    ${PLATFORM_FRAMEWORKS}
)
```

**链接器的智慧**：

iOS 构建时自动链接 UIKit 框架，macOS 构建时自动链接 IOKit 框架。JavaScriptCore 和 Foundation 是两个平台共享的，所以总是链接。

这样，iOS 代码可以调用 UIKit API，macOS 代码可以调用 IOKit API，而且不会有链接冲突。

## 🤯 Makefile 的一键魔法

最神奇的是，所有这些复杂的配置都被 Makefile 简化成了一条命令：

```bash
# macOS 构建 - 一条命令搞定
make build

# 实际执行的复杂流程：
# 1. js-build: npm run build (构建JavaScript bundle)
# 2. configure: mkdir build && cmake配置
# 3. build: make -j$(CORES) (并行编译)

# iOS 构建 - 同样一条命令
make ios-build

# 实际执行的复杂流程：
# 1. js-build: npm run build
# 2. ios-configure:
#    - mkdir build_ios
#    - DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer cmake
#    - CMAKE_SYSTEM_NAME=iOS
#    - CMAKE_OSX_ARCHITECTURES=$(uname -m)
#    - CMAKE_OSX_SYSROOT=$(xcrun --sdk iphonesimulator --show-sdk-path)
# 3. build: make -j$(CORES)
```

**Makefile 的魔法**：

开发者只需要记住 `make build` 和 `make ios-build`，背后的所有复杂性都被自动化了：
- 自动检测 CPU 核心数并行编译
- 自动配置 Xcode 开发环境
- 自动设置模拟器 SDK 路径
- 自动构建 JavaScript bundle

**一条命令，从源码到可执行文件！**

## 🏗️ 构建系统的完整魔法

把所有自动化串起来，整个流程是这样的：

```bash
# 为 iOS 构建
make ios-build

# Makefile 自动：
# 1. npm run build (构建 JavaScript bundle)
# 2. mkdir build_ios (创建独立的 iOS 构建目录)
# 3. 配置 Xcode 环境变量和 iOS 模拟器 SDK

# CMake 自动：
# 1. 检测到 CMAKE_SYSTEM_NAME=iOS
# 2. 选择 src/ios/modules/deviceinfo/DeviceInfoModule.mm
# 3. 设置 Objective-C++ ARC 编译标志
# 4. 链接 UIKit.framework (iOS专用)
# 5. 设置部署目标为 iOS 12.0+

# 编译器自动：
# 1. 只编译 iOS 平台的源文件
# 2. 链接 iOS 特定的框架
# 3. 生成 iOS 专用的静态库和测试程序
# 4. 自动复制 JavaScript bundle 到 iOS 应用包
```

**一条命令，自动完成平台适配！**

注意这里的巧妙设计：macOS 和 iOS 使用不同的构建目录（`build` vs `build_ios`），可以同时存在，切换时不需要清理。

## 🎨 工程化的艺术

这套自动化系统的精妙之处在于：

**开发时**：每个平台有独立的实现文件，便于维护和版本控制

**构建时**：CMake 根据目标平台自动选择源文件和框架，避免冗余和冲突

**部署时**：Makefile 提供统一的命令接口，隐藏平台差异的复杂性

```cpp
// 开发者的项目结构
src/
├── common/modules/DeviceInfoModule.h        // 共同接口
├── ios/modules/deviceinfo/DeviceInfoModule.mm     // iOS 实现
└── macos/modules/deviceinfo/DeviceInfoModule.mm   // macOS 实现

// iOS 构建时实际包含的文件
build_ios/
├── DeviceInfoModule.h
├── DeviceInfoModule.mm (iOS版本)
└── libmini_react_native.a (只包含iOS代码的静态库)

// macOS 构建时实际包含的文件
build/
├── DeviceInfoModule.h
├── DeviceInfoModule.mm (macOS版本)
└── libmini_react_native.a (只包含macOS代码的静态库)
```

**两个平台的代码完全分离，但共享同一个接口！**

这种设计比预编译宏更清晰：
- **可维护性**：每个平台的代码独立，修改不会影响其他平台
- **可测试性**：可以独立测试每个平台的实现
- **可扩展性**：添加新平台只需要新增实现文件，不需要修改现有代码

## 🚀 自动化的哲学

DeviceInfo 模块的自动化实现揭示了一个重要原则：

**好的跨平台架构不是让代码在所有平台都能跑，而是让正确的代码在正确的平台上跑。**

通过这个项目的三层自动化体系：

1. **Makefile 自动化**：统一的命令接口，隐藏平台配置复杂性
2. **CMake 自动化**：智能的源文件选择和框架链接
3. **编译器自动化**：平台特定的二进制生成

这样的架构让开发者专注于业务逻辑，而把平台适配的复杂性交给了工具链。

**关键洞察**：

真正的自动化不是写一份代码到处跑，而是：
- **开发体验统一**：`make build` vs `make ios-build`，命令接口一致
- **实现策略分离**：每个平台有最适合的实现方式
- **构建过程透明**：开发者不需要关心 Xcode SDK 路径、编译标志等细节

**这种设计在面对更复杂的系统时依然有效**：只要保持接口统一、实现分离、构建自动化，就能优雅地扩展到视图渲染、事件处理等更复杂的场景。