## 🎭 复用的残酷真相
上一节我们看到了抽象基类的魔法，但现在要面对一个更现实的问题：
**不是所有代码都能复用。**
那么问题来了：哪些能复用？哪些不能？这个边界是怎么划分的？

## 📊 复用率解密
让我们看看实际的复用率统计：

| 代码类型 | 复用率 | 为什么？ |
|---------|--------|----------|
| Bridge 通信逻辑 | 100% | 协议标准化 |
| 模块注册机制 | 100% | 框架层抽象 |
| 错误处理机制 | 100% | 异常处理逻辑相同 |
| 设备唯一标识 | 0% | 平台理念完全不同 |
| 系统版本获取 | 95% | 只有注释不同 |
| 设备型号获取 | 85% | 都用 sysctlbyname，iOS多了模拟器判断 |

**这个表格透露了什么秘密？**

注意一个有趣的发现：在实际代码中，`invoke` 方法目前只处理了 `getUniqueId`，其他两个方法虽然实现了，但没有在调用路径中。这是 MVP 开发的典型特征——先让核心功能跑通，再逐步完善。

## 🔍 100% 复用：协议的力量

**为什么 Bridge 通信能 100% 复用？**

```cpp
// 这段代码在任何平台都完全一样
void DeviceInfoModule::invoke(const std::string& methodName,
                             const std::string& args, int callId) {
    try {
        if (methodName == "getUniqueId") {
            std::string uniqueId = getUniqueIdImpl();
            sendSuccessCallback(callId, uniqueId);
        } else {
            sendErrorCallback(callId, "Unknown method: " + methodName);
        }
    } catch (const std::exception& e) {
        sendErrorCallback(callId, "Method invocation failed: " + std::string(e.what()));
    }
}
```

**因为这是协议层！**不管底层平台怎么变，JavaScript 和 Native 之间的通信协议是固定的。方法名、参数、回调 ID、错误处理...这些都是标准化的。就像 HTTP 协议，不管服务器是 Linux 还是 Windows，浏览器都用同样的方式发请求。

**为什么系统版本获取能 95% 复用？**

```cpp
// 两个平台的代码几乎完全一样
std::string DeviceInfoModule::getSystemVersionImpl() const {
    @autoreleasepool {
        // 获取单例 NSProcessInfo 实例，用于查询运行时进程/系统信息。
        NSProcessInfo* processInfo = [NSProcessInfo processInfo];
        // 调用 processInfo 的 operatingSystemVersion 方法
        NSOperatingSystemVersion version = [processInfo operatingSystemVersion];

        // 创建一个 C++ 的输出字符串流，用来拼接版本号字符串
        std::ostringstream oss;
        oss << version.majorVersion << "." << version.minorVersion << "." << version.patchVersion;

        return oss.str();
    }
}
```

**这是苹果生态的福利**：macOS 和 iOS 共享了大量底层框架，`NSProcessInfo` API 接口完全一致。唯一的差别是注释的详细程度（macOS 版本有更详细的注释）。

## 💥 0% 复用：平台的鸿沟

**为什么设备唯一标识完全不能复用？**

```cpp
// macOS - 使用 IOKit 硬件接口，多层降级机制
std::string DeviceInfoModule::getUniqueIdImpl() const {
    @autoreleasepool {
        // 尝试获取硬件 UUID
        io_registry_entry_t ioRegistryRoot =
            IORegistryEntryFromPath(kIOMasterPortDefault, "IOService:/");
        CFStringRef uuidCf = (CFStringRef)IORegistryEntryCreateCFProperty(
            ioRegistryRoot, CFSTR(kIOPlatformUUIDKey), kCFAllocatorDefault, 0);

        if (uuidCf) {
            // 成功获取硬件UUID，这是真正的硬件标识
            NSString* uuid = (__bridge NSString*)uuidCf;
            std::string result = [uuid UTF8String];
            CFRelease(uuidCf);
            return result;
        }

        // 降级到系统UUID，再降级到组合标识
        // 最后备选：生成基于设备信息的标识
        return "macOS-" + getDeviceIdImpl() + "-" + getSystemVersionImpl();
    }
}

// iOS - 每次启动生成新ID，适合MVP测试
std::string DeviceInfoModule::getUniqueIdImpl() const {
    @autoreleasepool {
        // iOS 简化实现：使用 NSUUID 生成唯一标识
        // 注意：这个实现每次启动都会生成新的ID，适用于MVP测试
        NSUUID* uuid = [NSUUID UUID];
        NSString* uuidString = [uuid UUIDString];
        return [uuidString UTF8String];
    }
}
```

**完全不同的世界！**

macOS 追求真正的硬件级别唯一性，有复杂的降级机制；iOS 在 MVP 阶段采用了简化策略，每次启动生成新ID。这不是技术问题，而是：

1. **平台哲学**的差异：桌面 vs 移动的隐私理念
2. **开发策略**的差异：完整实现 vs MVP验证

## 🎨 85% 复用：妥协的艺术

最有趣的是设备型号获取，为什么有 85% 复用率？

```cpp
// macOS - 直接使用 sysctlbyname
std::string DeviceInfoModule::getDeviceIdImpl() const {
    @autoreleasepool {
        size_t size = 0;
        sysctlbyname("hw.model", nullptr, &size, nullptr, 0);

        if (size > 0) {
            std::vector<char> buffer(size);
            if (sysctlbyname("hw.model", buffer.data(), &size, nullptr, 0) == 0) {
                return std::string(buffer.data());
            }
        }

        // 备选方案
        return "Unknown";
    }
}

// iOS - 同样的sysctlbyname，但用了hw.machine而不是hw.model
std::string DeviceInfoModule::getDeviceIdImpl() const {
    @autoreleasepool {
        // iOS 简化实现：直接使用 sysctl 获取设备型号（避免 UIDevice 依赖）
        size_t size = 0;
        sysctlbyname("hw.machine", nullptr, &size, nullptr, 0);

        if (size > 0) {
            std::vector<char> buffer(size);
            if (sysctlbyname("hw.machine", buffer.data(), &size, nullptr, 0) == 0) {
                return std::string(buffer.data());
            }
        }

        // 备选方案：iOS 模拟器标识
        return "iOS-Simulator";
    }
}
```

**有趣的发现**：
1. **核心逻辑 100% 相同**：都用 `sysctlbyname`，都用 `std::vector<char>` 做缓冲区
2. **参数略有差异**：macOS 用 `hw.model`，iOS 用 `hw.machine`
3. **降级策略不同**：macOS 返回 "Unknown"，iOS 返回 "iOS-Simulator"

这就是 85% 复用率的来源：算法和数据结构完全相同，只是参数和边界情况有差异。

## 🤔 复用边界的哲学

通过 DeviceInfo 模块，我们发现了跨平台复用的三个层次：

1. **协议层**：100% 复用，因为标准统一
2. **API 层**：看运气，苹果生态有优势
3. **实现层**：看平台差异，移动端更复杂

**这个发现有什么更深层的意义？**

它揭示了一个残酷的真相：**跨平台的成本永远存在，只是被转移了。**

你可以用抽象基类隐藏差异，但差异本身不会消失。关键是找到合适的边界，让复用最大化，让差异最小化。

但还有一个问题：这些平台差异的代码，在编译时是怎么自动选择的？