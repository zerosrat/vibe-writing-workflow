> 用户在整理博客文章结构时，需要详细说明从 macOS 单平台到 iOS+macOS 双平台，构建系统是如何演进和适配的。

## 技术挑战：从 macOS 到 iOS 的适配

### 2.1 构建系统的演进

**CMake 跨平台配置的细节**

从单平台到双平台，CMakeLists.txt 的变化体现了跨平台构建的精髓：

```cmake
# 原始版本 - 仅支持 macOS
if(APPLE)
    set(PLATFORM_SOURCES
        src/macos/modules/deviceinfo/DeviceInfoModule.mm
    )
    find_library(IOKIT_FRAMEWORK IOKit)
endif()

# 演进版本 - 支持 macOS + iOS
if(APPLE)
    # 根据具体平台选择源文件
    if(${CMAKE_SYSTEM_NAME} MATCHES "iOS")
        set(PLATFORM_SOURCES
            src/ios/modules/deviceinfo/DeviceInfoModule.mm
        )
    else()
        # macOS
        set(PLATFORM_SOURCES
            src/macos/modules/deviceinfo/DeviceInfoModule.mm
        )
    endif()

    # 共享的 Foundation 框架
    find_library(FOUNDATION_FRAMEWORK Foundation)

    # 平台特定框架
    if(${CMAKE_SYSTEM_NAME} MATCHES "iOS")
        find_library(UIKIT_FRAMEWORK UIKit)
        set(PLATFORM_FRAMEWORKS ${UIKIT_FRAMEWORK})
    else()
        find_library(IOKIT_FRAMEWORK IOKit)
        set(PLATFORM_FRAMEWORKS ${IOKIT_FRAMEWORK})
    endif()
endif()
```

**关键设计决策：**

1. **条件编译**：使用 `CMAKE_SYSTEM_NAME` 区分平台
2. **源文件分离**：不同平台的实现放在不同目录
3. **框架动态链接**：根据平台链接不同的系统框架

**仅 iOS 模拟器支持**

项目选择仅支持 iOS 模拟器，这是一个明智的简化：

- 真机测试需要证书和配置文件
- 模拟器足以验证 Bridge 通信机制
- 降低了环境配置的复杂度

```bash
# iOS 模拟器构建配置
ios-configure:
    @cd $(BUILD_DIR)_ios && cmake \
        -DCMAKE_SYSTEM_NAME=iOS \
        -DCMAKE_OSX_ARCHITECTURES=$$(uname -m) \
        -DCMAKE_OSX_SYSROOT=$$(xcrun --sdk iphonesimulator --show-sdk-path) \
        ..
```

**架构支持限制**

当前仅支持 Apple 芯片的 Mac 上的模拟器：

- `x86_64`：Intel Mac 上的模拟器
- `arm64`：Apple Silicon Mac 上的模拟器
- 不支持：真机的 arm64（需要额外的签名配置）

### 2.2 平台特定框架

**macOS: IOKit（设备信息获取）**

```objective-c
// src/macos/modules/deviceinfo/DeviceInfoModule.mm
#import <IOKit/IOKit.h>

- (NSString *)getDeviceId {
    size_t len = 0;
    sysctlbyname("hw.machine", NULL, &len, NULL, 0);
    char *machine = (char *)malloc(len);
    sysctlbyname("hw.machine", machine, &len, NULL, 0);
    NSString *deviceId = [NSString stringWithUTF8String:machine];
    free(machine);
    return deviceId;
}
```

**iOS: UIKit（设备信息获取）**

```objective-c
// src/ios/modules/deviceinfo/DeviceInfoModule.mm
#import <UIKit/UIKit.h>

- (NSString *)getDeviceId {
#if TARGET_OS_SIMULATOR
    return @"x86_64";  // 模拟器统一返回
#else
    // 真机获取具体设备型号
    struct utsname systemInfo;
    uname(&systemInfo);
    return [NSString stringWithUTF8String:systemInfo.machine];
#endif
}
```

**共享: JavaScriptCore.framework + Foundation**

这两个框架是跨平台的基础：

- **JavaScriptCore**：提供 JavaScript 执行环境
- **Foundation**：提供基础数据类型和工具

### 构建系统的设计哲学

**单一配置文件，多平台支持**

通过 CMake 的条件判断，实现：
- 一套 CMakeLists.txt 支持所有平台
- 平台差异通过条件编译处理
- 避免维护多套构建配置

**Makefile 作为统一接口**

```makefile
# macOS 构建
build: js-build configure
    @cd $(BUILD_DIR) && make -j$(CORES)

# iOS 构建
ios-build: js-build ios-configure
    @cd $(BUILD_DIR)_ios && make -j$(CORES)
```

Makefile 提供了语义化的构建目标，隐藏了 CMake 的复杂性。

**资源文件的处理**

iOS 需要将 JavaScript bundle 复制到应用包：

```cmake
# iOS 特定配置：复制 JavaScript bundle 到应用包
if(${CMAKE_SYSTEM_NAME} MATCHES "iOS")
    add_custom_command(TARGET test_integration POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
        "${CMAKE_SOURCE_DIR}/dist/bundle.js"
        "$<TARGET_FILE_DIR:test_integration>/bundle.js"
        COMMENT "Copying JavaScript bundle to iOS app package"
    )
endif()
```

这种设计确保了：
- macOS：直接从文件系统读取
- iOS：从应用 bundle 读取
- 对 JavaScript 代码完全透明

> 这张卡片详细记录了构建系统从单平台到多平台的演进过程，展示了如何通过 CMake 和 Makefile 的组合，实现优雅的跨平台构建方案。